---
title: "Getting a Free Computer Science Education: Part 3"
date: "2018-05-24"
layout: post
draft: false
path: "/posts/journey-3/"
category: "Study"
tags:
  - "Study"
description: "Which classes and when?"
---

## Sequences

We established in my [last post](/posts/journey-2/) that my self study adventure will take approximately 2 years to complete if I study 16 hours a week.

But it's a little more complicated than that. The classes are organized into different subjects and usually depend on other classes. Organizing the pre-requisite dependencies into __sequences__, we have the following:
#### Coding
31 weeks
```
How to Code - Simple Data 7 weeks
How to Code - Complex Data 6 weeks
Software Construction - Data Abstraction	6 weeks
Software Construction - Object-Oriented Design	6 weeks
Software Engineering: Introduction	6 weeks
```
#### Languages
10 weeks
```
Programming Languages, Part A	4 weeks
Programming Languages, Part B	3 weeks
Programming Languages, Part C	3 weeks
```
#### Math and Theory
98 weeks
```
Linear Algebra - Foundations to Frontiers 15 weeks
Calculus 1A: Differentiation 13 weeks
Calculus 1B: Integration 13 weeks
Calculus 1C: Coordinate Systems & Infinite Series	13 weeks
Mathematics for Computer Science1	13 weeks
Algorithms: Design and Analysis, Part I	8 weeks
Algorithms: Design and Analysis, Part II	8 weeks
ops-class.org - Hack the Kernel	15 weeks
```
#### Systems
12 weeks
```
Build a Modern Computer I 6 weeks
Build a Modern Computer II 6 weeks
```
#### Applications
41 weeks (after linear algebra)
```
Machine Learning 11 weeks
Introduction to Computer Science with Python 9 weeks
Databases	12 weeks
Cryptography I 6 weeks
Introduction to Computer Networking	8 weeks
Computer Graphics	6 weeks
```

#### Capstone
7 weeks (last)
```
Software Development Capstone Project	7 weeks
```

## Not Doing the Math

Obviously the longest sequence is Math and Theory. If I'm going by the course schedule, it would take almost a year and a half to complete. So those classes will have to be the basis for the whole course. This would be the plan for finishing that sequence as soon as possible.

And, full disclosure, I might end up doing some of the math classes at a community college. This will depend on how far I can get into calculus on my own. I think the math foundations are one of the most important pieces and I feel it's more like martial arts than running a marathon. Though painful, one can run accomplish marathon with very little training. With martial arts, it's almost impossible to be competitive without constant training.

Anyway, I tried a few different ways to come up with a calendar or exact schedule for taking these classes and I couldn't find one that made sense. There were too many problems with that setup:

- If a course goes faster than planned, I could risk taking breaks just to adhere to an arbitrary schedule.
- If a course is difficult and I fall behind, I might have to delay the end date. This is not good, extra time should be accounted for in the timeline. I would have to basically just guess which courses are going to be more difficult.
- It's extremely time consuming just to build a calendar for this thing much less update and share it.

But I want to at least know what I'm going to be doing ahead of time. Having the guideline will be super important so I always know how my work is fitting into the overall goal. This also prevents me from getting lost in any one course subject. It's easy for me to get lost in rabbit holes, following impulses instead of long term goals.

## Magic Bag

So I think a good compromise will be a hierarchical list of sequences.

I'll start with my estimated budget of __16 hours a week__.

Then I'll fill up the budget with hours picking from the top down and only taking one course from each sequence at time.

When I finish a course I'll pick the next one from the top, as long as I'm not already taking a course from the sequence or have completed that sequence.

```
1. Math and Theory
2. Coding
3. Systems
4. Languages
5. Applications
6. Capstone
```

This sounds kind of like a [memory stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) but I'm sure I'll learn exactly how that comparison is wrong in the months to come.

That means the first group of courses will be the following:

```
Linear Algebra - 15 weeks 8 hours per week
How to Code I - 7 weeks 7 - 8 hours per week
```

When I finish `How to Code - Simple Data` I'll pick the next one from that list and my schedule becomes:

```
Linear Algebra - 15 weeks 8 hours per week
How to Code I - 6 weeks 6 - 8 hours per week
```

You could see how this algorithm could be used to generate a schedule that I could publish on this website but I think that would be, again, too prescriptive and missing the point. I landed the hierarchical list because it adds time agnostic flexibility. I'll always have an option of __what__ to study next no matter __when__ you get to it. The decisions about what to do next are made ahead of time ,given I don't need to make adjustments which will be easy to make.

## Guesstimating

It will be good to set __some kind of a time based goal__ for the completion of this project. It will help add a level of accountability. I'll have to see what exactly this entails once I get started. Perhaps after one month, I'll come back and see what kind of progress I've made.

I just need a way to keep track of the __hours spent working every week__, specifying the course worked on, and __a percentage of completion__ on each course. With these two metrics it becomes really simple to predict a completion date and just compare it to the course timeline.

```
estimated weeks left = (total hours spent / (units completed / total units)) / weekly budget
```

The weekly budget is 16 right now but that could change once I get started.

Comparing the project completion date to the course's syllabus timeline should serve as a good guiding goal. If the course says 13 weeks and my project completion time is 18 weeks, I know that I might need to pick it up. If my projected completion is 9 weeks, then I should try to keep that pace and finish early.

The overall goal timeline for the courses will stay at roughly __1.5 years__ as outlined in part 2.

## Why Measure?

I'm interested in measuring my progress because I believe in cognitive behavioral science over the power of my will. It's my individual experience that simply willing myself to change my habits is not very successful. In fact, and I can't express enough how much this is my __individual experience__, simply trying hard can lead to burn out.

Another way to think of this is a concept I learned when I was getting my education degree. The idea is that there are two types of learners: `approach and avoidant` and `achievement motivated`. [You can read more about it in this very dry article.](http://www.personalityresearch.org/papers/rabideau.html)

So what's the difference between the two? `Achievement motivated` people actually want to achieve the thing. They will make adjustments, overcome setbacks, take breaks and value efficiency over grandiose displays of effort.

`Approach/Avoidant` people just want to make the valiant attempt. They may actually subconsciously find ways to sabotage themselves so they can justify it when they inevitably give up. In a class setting they will be more likely to take short cuts, procrastinate and end up cramming for the test the night before. We all know cramming to pass a test is not a good way to learn a subject.

This is a pitfall I have fallen into plenty of times and I want to not do it this time. I'll need to:

- take objective measurements of my progress
- make good faith reflections/adjustments to my plan
- stay focused on the long term goal
- never make things needlessly difficult
- make sure I am enjoying learning the subject the great majority of the time
- read supplemental materials
- remember that the only way to fail is to stop trying

## Final Thoughts

I recently came upon an idea while working on a project. I noticed that I was getting very depressed when I couldn't figure something out quickly. I was reminding myself of countless young kids I had counseled at summer camps. Kids who would throw a pity party any time they couldn't __immediately__ do anything.

A lot of times the fix for these kids is that they develop a healthy self esteem. Kids are narcissists and that pattern often results in all or nothing types of social calculations. One thinks "If I'm not perfect, then I'm disgusting" to themselves.

So at the end of the day, achievement comes down to self esteem. Let yourself fail. Stay humble (thanks to Jocko for that concept) and let yourself be completely wrong once in a while so you can fix it! .

> Let yourself fail.<br>
> \- Alex (motivational writer)

Thanks for reading. I think I'll make a progress bar indicator that will sit below my profile picture next. (Hey isn't this Gatsby Lumen site nifty?)

\- Alex
