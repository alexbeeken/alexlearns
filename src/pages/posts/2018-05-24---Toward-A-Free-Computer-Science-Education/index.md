---
title: "Toward a Free Online Computer Science Education"
date: "2018-05-24"
layout: post
draft: false
path: "/posts/toward-a-free-computer-science-education/"
category: "Study"
tags:
  - "Study"
description: "I've wanted to study computer science formally for a few years now. I've given up on affording going back to school full time. In this article, I outline and structure my goal of educating myself in the ways of computer science from the free OSSU computer science degree guide."
---

Okay, you caught me. I'm a graduate of a code school. Dang, I almost snuck by without getting caught. And I could have gotten a job too if it weren't for you meddling kids!

Just kidding, I was actually able to B.S. my way into a web development job when I graduated. But give me a break, I didn't mean to. I got into coding because computers are fascinating, incredibly useful and have the unimaginable potential to influence society. The job was just a happy accident. For years, my goal has been to go back to school and study computer science at a university... you know like a real hacker... when I have enough money.

> I want to go back to school and study computer science.
<br>
> \- Alex (for years)

But money is something that I am not good at getting. I mean, I *could* have it if I was boring. You know, if I kept a job for more than 3 years like an adult. But life is to be lived! I've just been too excited about the potpourri of experiences this world has to offer to spend my days chained to a desk... for more than 2 years at a time.

> Life is to be lived.
<br>
> \- Alex (stays in most nights)

Well, the time to commit is now. Enter the OSSU (bows down on the floor.)

![The Open Source Society University logo](https://camo.githubusercontent.com/ab1e7ce255025d6c6b9431d43409217c21f70b6a/687474703a2f2f692e696d6775722e636f6d2f6b5959435874432e706e67)

Last week, out of desperation, I googled "How to Get a Free Computer Science Degree" and came across this [github repo](https://github.com/ossu/computer-science). The OSSU put together this list of free online courses to serve as a comprehensive and well rounded substitute for a formal degree. MOOCs were actually my introduction to coding, beginning with cs50. I was happy to see that cs50 was actually on the OSSU list too.

It's no secret that tuition in the united states is expensive. For an all online computer science degree from OSU, you're looking at a bill of $26,000. The most conveniently located 4 year university for me is Portland State University, costing around $9000 per year. Taking classes at PCC, about 20 minutes of driving for me, costs about half that but, being a community college, only offers half of a complete program.

## The Quest

Therefore, I have decided I am going to complete the OSSU computer science tract and become a self made Bachelor of Computer Science.

> I'm going to become a self made Bachelor of Computer Science.<br>
> \- Alex (gives up on most projects after two weeks)

No, really though. This is something I've wanted for years and I strongly believe in free education. MOOC learning is better on almost every level except for a few small details like:

- FACE TO FACE INTERACTION
- ACCOUNTABILITY

Oh shoot. This might be harder than I thought. As an independent contractor, I understand how challenging it is to manage ones self. I can be moody, be easily distracted, go through random episodes of mild mania and not as mild depression. I am very motivated by face to face interaction and I am certainly not someone who always finishes what they start.

## Self Management

It's not all bad though. I've learned a few tricks. This project will probably require clever use of them all. The road is long, dark and full of enemies but so am I! (what?)

Some tricks of the trade:

1. __This Blog__ writing and sharing what I'm learning is going to help me feel accountable, give me a place to vent and let me practice some creative writing.

2. __Videos__ I love making videos. It would be really fun to make some videos just sharing cool things that I'm learning and if people watch it then BOOM that counts as human interaction doesn't it?

3. __A Big Whiteboard__ my roommate bought me a huge whiteboard last year that sits permanently fixed to my wall next to my bed. I LOVE IT.

4. __Todo Lists__ you know the feeling when you scratch an itch? That's what checking a box feels like on a todo list.

5. __Coffee__ a little caffeine in the morning is the best feeling ever. A lot of caffeine in the morning makes my fingers tingly and I get panic attacks.

6. __Spiral Notebooks__ the original Google Docs.

7. __iPad Pro__ OneNote on iPad is best of both OS worlds.

8. __Spotify__ To drown out loud teenagers and phone talkers in the coffeeshops.

9. __Coffee Shops__ when I need some new music for my Spotify.

10. __Twitter__ I don't like twitter but it might be a good way to find other people doing what I'm doing.

11. __Supplemental Materials__ taking the time to go more into depth will make the whole experience better.

12. __Explainer Videos__ one of the best things to happen to education in the last 10 years.

13. __Golden Hours__ those first 4 hours of every work day are precious. I have to make sure they are not wasted.

14. __Healthy Food__ to make sure my brain functions.

## The Time Frame

This is a huge commitment. I will need to act as my own professor, advisor and career counselor all at once. So, I slipped between the Google Sheets to help get an idea of the scope of this undertaking. The estimated __minimum__ number of hours to complete the program is __1302.3__. Why minimum? I think I'll come in closer to the minimum because I already have some experience in the industry. In fact, a lot of early classes, I will be learning notation and the "academic way" of thinking about things I already have experience with. Full disclosure, I have also taken Precalculus and Calculus 1 within the last 2 years in formal college classrooms.

1302.3 hours is around 110 days if I work for 12 hours straight and never take a day off.[If I took holidays and weekends off](https://www.timeanddate.com/date/workdays.html?d1=23&m1=5&y1=2018&d2=30&m2=10&y2=2018&), it would take 160 calendar days. From the date of this posting that means I'll be done just in time for Halloween! (yay)

Let's say, and this is purely hypothetical, that I have a life and a full time job. That means I would probably only have time to consistently do four 4 hour sessions during the week. This gives me the chance to work it all out during the week or put things off until the weekend if I need to. This limits me to __16 hours a week__.

1302.3 total hours / 16 hours per week = about 80 weeks. [80 weeks from today puts me at December 4, 2019](https://www.timeanddate.com/date/durationresult.html?m1=5&d1=23&y1=2018&m2=4&d2=21&y2=2020&ti=on). So, __about 1.5 years__... going by the *minimum* hour requirement.

Does this make me feel discouraged? At first glance, hells yeah. But at second glance, 1.5 years isn't that much time. 1.5 years ago, I was the same person I am today. I had the same dreams about going to school that I have today. In fact, I did take a few online classes that I never finished. Do I appreciate the work that I did 1.5 years ago? hells yeah. Will I appreciate this work in 10 years? 100%.

![No Ragrets tattoo design - ragrats is spelled wrong  which is pretty ironic for a tattoo](https://taintedtats.com/pub/media/catalog/product/cache/c687aa7517cf01e65c009f6943c2b1e9/n/o/no-ragrets-temporary-tattoo-tt0218.jpg)

*NO RAGRETS!*

>Finishing a project should never, in itself, be the goal. Finishing is just an opportunity to reflect on the next move.<br>
> \- Alex (guy who never finishes projects)

## Sequences
We've established that my self study adventure will take approximately 1.5 years to complete given a 16 hours weekly time budget. But it's a little more complicated than that. The classes are organized into different subjects and most classes have other classes as prerequisites. Organizing these prerequisite dependencies into __sequences__, we have the following:
#### Coding
31 weeks

|Course | Length |
|---|:-:|
| How to Code I | 6 weeks |
| How to Code II | 6 weeks |
| Software Construction I | 6 weeks |
| Software Construction II | 6 weeks |
| Software Engineering | 6 weeks |

#### Languages
10 weeks

|Course | Length |
|---|:-:|
| Programming Languages I | 4 weeks |
| Programming Languages II | 3 weeks |
| Programming Languages III | 3 weeks |

#### Math and Theory
98 weeks

|Course | Length |
|---|:-:|
| Linear Algebra | 15 weeks |
| Calculus 1A | 13 weeks |
| Calculus 1B | 13 weeks |
| Calculus 1C | 13 weeks |
| Mathematics for Computer Science | 13 weeks |
| Algorithms I | 8 weeks |
| Algorithms II | 8 weeks |
| ops-class.org - Hack the Kernel |	15 weeks |
#### Systems
12 weeks

|Course | Length |
|---|:-:|
| Build a Modern Computer I | 6 weeks |
| Build a Modern Computer II | 6 weeks |

#### Applications
41 weeks (after linear algebra)

|Course | Length |
|---|:-:|
| Machine Learning | 11 weeks |
| Introduction to Computer Science with Python | 9 weeks |
| Databases	| 12 weeks |
| Cryptography I | 6 weeks |
| Introduction to Computer Networking |	8 weeks |
| Computer Graphics	| 6 weeks |

#### Capstone
7 weeks (last)

|Course | Length |
|---|:-:|
| Software Development Capstone Project	| 7 weeks |

## Not Doing the Math

Full disclosure, I might end up doing some of the math classes at a community college. This will depend on how far I can get into calculus on my own. I think the math foundations are one of the most important pieces and I feel it's more like martial arts than running a marathon. Though painful, one can run accomplish marathon with very little training. With martial arts, it's almost impossible to be competitive without constant training.

Anyway, I tried a few different ways to come up with a calendar or exact schedule for taking these classes and I couldn't find one that made sense. There were too many problems with that setup:

- If a course goes faster than planned, I could risk taking breaks just to adhere to an arbitrary schedule.
- If a course is difficult and I fall behind, I might have to delay the end date. This is not good, extra time should be accounted for in the timeline. I would have to basically just guess which courses are going to be more difficult.
- It's extremely time consuming just to build a calendar for this thing much less update and share it.

But I want to at least know what I'm going to be doing ahead of time. Having the guideline will be super important so I always know how my work is fitting into the overall goal. This also prevents me from getting lost in any one course subject. It's easy for me to get lost in rabbit holes, following impulses instead of long term goals.

## Magic Bag

Let's find a way to decide the order of classes to take, at least. The longest sequence is Math and Theory. In fact, it would take almost almost two years to complete this sequence alone. So those classes will have a higher priority than the rest. The next longest sequence is less than half as long, so we're not as concerned with length for determining which sequences are second, third or fourth priority.

But it makes sense to take care of any prerequisites early because it adds more flexibility later on. It also avoids situations where there are 7 classes left and I have to take them one by one unnecessarily delaying my symbolic graduation.

So I put sequences into a hierarchy and use this list to spend my estimated budget of 16 hours a week. When I finish a course I'll pick the next one in the sequence, as long as I'm not already taking a course from the sequence or have completed that sequence.

1. Math and Theory
2. Coding
3. Systems
4. Languages
5. Applications
6. Capstone

This sounds kind of like a [memory stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) but I'm sure I'll learn exactly how that comparison is wrong in the months to come.

That means the first group of courses will be the following:

|Course | Length | Time Cost |
|---|:-:|:-:|
| Linear Algebra	| 15 weeks | 8 hours per week |
| How to Code I	| 7 weeks | 7 - 8 hours per week |

When I finish `How to Code - Simple Data` I'll pick the next one from that list and my schedule becomes:

|Course | Length | Time Cost |
|---|:-:|:-:|
| Linear Algebra	| 15 weeks | 8 hours per week |
| How to Code II	| 6 weeks | 6 - 8 hours per week |

You could see how this algorithm could be used to generate a schedule that I could publish on this website but I think that would be, again, too prescriptive and missing the point. I landed the hierarchical list because it adds time agnostic flexibility. I'll always have an option of __what__ to study next no matter __when__ you get to it. The decisions about what to do next are made ahead of time ,given I don't need to make adjustments which will be easy to make.

## Guesstimating

It will be good to set __some kind of a time based goal__ for the completion of this project. I want to have a level of accountability but I don't want to prescribe a strict set of deadlines. I think I just need a timeframe to shoot for and a simple way to see if I'm close to hitting it.

This can be accomplished with two simple data points. The __hours spent working every week__ and __a percentage of completion__ on each course. With these two metrics it becomes really simple to predict a completion date.

```
estimated weeks left = (total hours spent / (units completed / total units)) / weekly budget
```

The overall goal timeline for the courses will stay at roughly __1.5 years__. The more time I spend on courses the more accurate the prediction becomes and the more I am able to adjust my pace to something challenging but still realistic.

## Why Measure?

I'm interested in measuring my progress because I believe in cognitive behavioral science over the power of my will. Simply willing myself to do something is hardly ever successful.

It makes me think of this concept I learned when I was getting my education degree. The idea is that there are two types of learners: `approach and avoidant` and `achievement motivated`. [You can read more about it in this very dry article.](http://www.personalityresearch.org/papers/rabideau.html)

So what's the difference between the two? `Achievement motivated` people actually want to achieve the thing. They will make adjustments, overcome setbacks, take breaks and value efficiency over grandiose displays of effort.

`Approach/Avoidant` people just want to make the valiant attempt. They may actually subconsciously find ways to sabotage themselves so they can justify it when they inevitably give up. In a class setting they will be more likely to take short cuts, procrastinate and cram for tests. We all know cramming is not a good way to learn.

This is a pitfall I have fallen into plenty of times but I won't this time! I'll need to:

- take objective measurements of my progress
- make good faith reflections/adjustments to my plan
- stay focused on the long term goal
- never make things needlessly difficult
- make sure I am enjoying learning the subject the great majority of the time
- read supplemental materials
- remember that the only way to fail is to stop trying

I have learned over the years that achievement largely comes down to healthy self esteem. It takes a strong sense of self to celebrate successes and let yourself fail without becoming discouraged.

> Let yourself fail.<br>
> \- Alex (motivational writer)

Thanks for reading. I think I'll make a progress bar indicator that will sit below my profile picture next. (Hey isn't this Gatsby Lumen site nifty?)

LETS GET STARTED!!!

![gif of a little boy who is unreasonable excited](https://media.giphy.com/media/3oEduOnl5IHM5NRodO/giphy.gif)

\- Alex
